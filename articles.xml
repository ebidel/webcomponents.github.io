<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title><![CDATA[WebComponents.org]]></title>
        <description><![CDATA[A place to discuss and evolve Web Component best-practices]]></description>
        <link>http://webcomponents.org</link>
        <generator>RSS for Node</generator>
        <lastBuildDate>Fri, 22 Jul 2016 12:31:19 GMT</lastBuildDate>
        <atom:link href="http://webcomponents.org/articles.xml" rel="self" type="application/rss+xml"/>
        <pubDate>Fri, 22 Jul 2016 12:30:23 GMT</pubDate>
        <item>
            <title><![CDATA[Server-side Web Components: How and Why?]]></title>
            <description><![CDATA[<p>Currently Web Components greatest use cases have been in front end web development. What about the back end? It turns out that Web Components are not only useful for the browser but they are also useful for raw functionality. This article talks about the key benefits in having Server Side Web Components.</p>
]]></description>
            <link>http://webcomponents.org/articles/server-side-web-components-how-and-why</link>
            <guid isPermaLink="true">http://webcomponents.org/articles/server-side-web-components-how-and-why</guid>
            <pubDate>Wed, 13 Jul 2016 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Web component challenges]]></title>
            <description><![CDATA[<p>People still seem wary of making use of web components because they are new, some of the standards are still in flux and there is yet to be a solid set of best practices discovered. Because of this I thought it best to address some of the issues head on and offer some solutions.</p>
<!-- Excerpt -->]]></description>
            <link>http://webcomponents.org/articles/web-component-challenges</link>
            <guid isPermaLink="true">http://webcomponents.org/articles/web-component-challenges</guid>
            <pubDate>Tue, 28 Jun 2016 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Why web components are so important]]></title>
            <description><![CDATA[<p>Over the past couple of years there has been up and down buzz around web components. It’s been said that they will change the way we build for the web — why is that, what makes web components so important?</p>

<!-- Excerpt -->]]></description>
            <link>http://webcomponents.org/articles/why-web-components-are-so-important</link>
            <guid isPermaLink="true">http://webcomponents.org/articles/why-web-components-are-so-important</guid>
            <pubDate>Tue, 28 Jun 2016 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[A Quick Introduction To Polymer]]></title>
            <description><![CDATA[<p>A guide to Polymer and its build tools.</p>
<!-- Excerpt -->
<p><blockquote style="margin-top:60px;margin-bottom:30px;font-style:italic;color:grey;font-size:1.5em">I&#39;ve a feeling we&#39;re not in Kansas anymore - Dorothy</blockquote>
<br/><br/></p>
<h1 id="web-component-recap">Web component recap</h1>
<p>Web components are a set of standards for creating reusable HTML elements.</p>
<p>For example if you wanted to create an image carousel, you could make a new html element <code>&lt;image-carousel&gt;</code>, with all it&#39;s JavaScript and CSS inside the element itself. After that is done, you could use this element anywhere in your document.</p>
<p>A key feature of Web Components is the Shadow DOM, which encapsulates everything inside your element. So in the example above, CSS and JS won&#39;t interfere from other elements or global scripts, preventing JS conflicts and CSS bleed.</p>
<h2 id="browser-support-">Browser support?</h2>
<p>The four areas of web components are:</p>
<ul>
<li><a href="http://www.w3.org/TR/html-imports/">HTML imports</a></li>
<li><a href="http://www.w3.org/TR/html-templates/">HTML templates</a></li>
<li><a href="http://www.w3.org/TR/custom-elements/">Custom elements</a></li>
<li><a href="http://www.w3.org/TR/shadow-dom/">Shadow DOM</a>.</li>
</ul>
<p>Browser support figures can be found here — <a href="http://caniuse.com/#search=web%20components">http://caniuse.com/#search=web%20components</a>.</p>
<p>All the major browsers have committed support for the v1.0 of the Shadow DOM specification, v1.0 of custom elements and HTML 5 templates.</p>
<ul>
<li><a href="https://webkit.org/blog/6017/introducing-safari-technology-preview/">Safari</a></li>
<li><a href="https://developer.microsoft.com/en-us/microsoft-edge/platform/status/shadowdom">Internet Explorer</a></li>
<li><a href="https://hacks.mozilla.org/2015/11/an-update-on-web-components-and-firefox/">Firefox</a></li>
</ul>
<h2 id="html-imports">HTML imports</h2>
<p>The sticking point is HTML imports. Chrome has a native implementation, but <a href="http://stackoverflow.com/questions/21177267/es6-modules-vs-html-imports">other browsers</a> are looking to Javascript ES6 modules (with a polyfill for HTML imports).</p>
<h2 id="webcomponents-js">webcomponents.js</h2>
<p>Browser support is varying (at the time of writing) so <a href="https://github.com/webcomponents/webcomponentsjs">webcomponents.js</a> was made to polyfill the web components API.</p>
<p>This code provides all you need to get started with web components!</p>
<h1 id="what-is-polymer-js-">What is Polymer JS?</h1>
<p>There are a few wrappers around web components such as <a href="http://x-tag.readme.io/">x-tag</a> and <a href="https://bosonic.github.io">bosonic</a>.</p>
<p><a href="https://www.polymer-project.org">Polymer</a> is a similar wrapper with a few extra goodies thrown in on top.</p>
<p>The aim of the Polymer project is not to create a bloated library, but instead make the smallest library possible, and make the browser do all the work.</p>
<p><a href="https://www.polymer-project.org/1.0/blog/2016-05-26-IO-2016-Recap.html">#UseThePlatform</a> is the name Polymer give to represent the want for the browser to do all the heavy lifting without libraries.</p>
<p>One of the advantages of using Polymer is that it has a built in data binding model (like <a href="https://angular.io">Angular</a>) enabling complete applications to be made without any other libraries.</p>
<p>Polymer <a href="https://www.polymer-project.org/1.0/docs/browsers">supports all major evergreen browsers</a> and when combined with webcomponents.js supports IE 11+.</p>
<h1 id="getting-started">Getting started</h1>
<p>To get started with Polymer, we are going to make our own element called <em>my-element</em> (all custom elements need a name with a dash in it).</p>
<pre class="highlight"><code class="hljs nimrod">&lt;dom-module id=<span class="hljs-string">"my-element"</span>&gt;
  &lt;<span class="hljs-keyword">template</span>&gt;
  &lt;/<span class="hljs-keyword">template</span>&gt;
  &lt;script&gt;
    <span class="hljs-type">Polymer</span>({
      <span class="hljs-keyword">is</span>: <span class="hljs-string">"my-element"</span>
    });
  &lt;/script&gt;
&lt;/dom-module&gt;
</code></pre><p>Save this in a file called <code>my-element.html</code>. We have declared the name of the element twice (once in the dom-module and once in the Polymer declaration). We can now load our element using <code>&lt;my-element&gt;&lt;/my-element&gt;</code>.</p>
<p>Lets add a bit of styling and a string data binding:</p>
<pre class="highlight"><code class="hljs nimrod">&lt;dom-module id=<span class="hljs-string">"my-element"</span>&gt;
  &lt;<span class="hljs-keyword">template</span>&gt;
    &lt;style&gt;
    .box{
      color: grey;
    }
    &lt;/style&gt;
    &lt;<span class="hljs-keyword">div</span> class=<span class="hljs-string">"box"</span>&gt;{{mybinding}}&lt;/<span class="hljs-keyword">div</span>&gt;
    &lt;/<span class="hljs-keyword">template</span>&gt;
    &lt;script&gt;
      <span class="hljs-type">Polymer</span>({
        <span class="hljs-keyword">is</span>: <span class="hljs-string">"my-element"</span>,
        properties: {
          mybinding: {
            <span class="hljs-keyword">type</span>: <span class="hljs-type">String</span>,
            value: <span class="hljs-string">"My text here"</span>
          }
        }
      });
    &lt;/script&gt;
&lt;/dom-module&gt;
</code></pre><p>We have added a <code>&lt;style&gt;</code> block <em>inside</em> our element (these styles are not available outside our element) and added a properties block to the Polymer section. Each property allows us to bind data from the outside world to our element. The double-moustache syntax <code>{{}}</code> is replaced by Polymer with the realtime value of the property.</p>
<p>To modify the property you can use attributes:</p>
<pre class="highlight"><code class="hljs applescript">&lt;<span class="hljs-keyword">my</span>-element mybinding=<span class="hljs-string">"Hello, World"</span>&gt;&lt;/<span class="hljs-keyword">my</span>-element&gt;
</code></pre><p>Or they can be changed programatically:</p>
<pre class="highlight"><code class="hljs actionscript">myobj.<span class="hljs-keyword">set</span>(<span class="hljs-string">'mybinding'</span>,<span class="hljs-string">'Hello again!'</span>);
<span class="hljs-comment">//myobj being a reference to your element in the DOM</span>
</code></pre><p>To put this all together:</p>
<pre class="highlight"><code class="hljs xml"><span class="hljs-doctype">&lt;!doctype html&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">meta</span> <span class="hljs-attribute">charset</span>=<span class="hljs-value">"utf-8"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">src</span>=<span class="hljs-value">"components/webcomponentsjs/webcomponents-lite.js"</span>&gt;</span><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">link</span> <span class="hljs-attribute">rel</span>=<span class="hljs-value">"import"</span> <span class="hljs-attribute">href</span>=<span class="hljs-value">"components/polymer/polymer.html"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">link</span> <span class="hljs-attribute">rel</span>=<span class="hljs-value">"import"</span> <span class="hljs-attribute">href</span>=<span class="hljs-value">"my-element.html"</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-title">my-element</span> <span class="hljs-attribute">mybinding</span>=<span class="hljs-value">"Hello, world"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-title">my-element</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">html</span>&gt;</span>
</code></pre><p>Our final example above loads webcomponents-lite, Polymer and our new element into our page.</p>
<p>The <a href="https://www.polymer-project.org/1.0/docs/devguide/feature-overview">Polymer documentation</a> describes all the features in more detail, but the above example describes the basics of making a customizable element.</p>
<h1 id="polymer-tips-and-tools">Polymer tips and tools</h1>
<h2 id="prpl-pattern">PRPL pattern</h2>
<p>PRPL (pronounced purple) is a set of concepts to enable the next generation of web applications:</p>
<ul>
<li>Push - send critical components for apps initial view</li>
<li>Render - load the initial screen ASAP</li>
<li>Pre-cache - store the elements for remaining views</li>
<li>Lazy-load - when a new view is called, load the elements</li>
</ul>
<p>This pattern relies on <a href="https://http2.github.io">HTTP 2</a> for the push capability (when you request only one element or page, the server recommends other files to cache to prevent having the browser work this out at a later time). The pre-cache relies on <a href="http://www.w3.org/TR/service-workers/">service workers</a> to pull down (but not upgrade) all the other elements required for the routes. These elements will then be upgraded at the point in time they are needed (and all the code for this is in the browser cache).</p>
<h2 id="speeding-up-with-vulcanization">Speeding up with vulcanization</h2>
<p>Most browsers don&#39;t natively support HTML imports out-of-the-box so they will need to be polyfilled. The problem with polyfills are that they are slower than native implementations. Worse than that, HTML Imports allow you to import an element, and then, in turn, that imported element can now import more dependent elements, and so on and so forth.</p>
<p>This dependency chain can be slow to import so a compiler (<a href="https://github.com/Polymer/vulcanize">vulcanize</a>) was written to combine all dependencies. Using a compiler like Vulcanize assembles your imports into one flat file so that only that one HTML import is needed.</p>
<p>The PRPL pattern is the opposite of vulcanization. This pattern only loads the minimum individual elements needed to show whats on screen, then lazily load the others.</p>
<p>Polymer&#39;s new <a href="https://github.com/Polymer/polymer-cli">CLI</a> is a tool that can be used for generating both PRPL and a vulcanized version of your project.</p>
<h2 id="polybuild">Polybuild</h2>
<p><a href="https://github.com/PolymerLabs/polybuild">Polybuild</a> is a tool that lives on top of vulcanize and makes it super easy to vulcanize a file and split the output into two files: a HTML file for the <a href="http://www.html5rocks.com/en/tutorials/webcomponents/template/">templates</a> and a JavaScript file for the Polymer code.</p>
<h2 id="sanitising-your-components">Sanitising your components</h2>
<p>The Polymer project has an optional utility known as  <a href="https://github.com/Polymer/hydrolysis">Hydrolysis</a> that can be used to analyze elements. Using Hydrolysis, a tool called  <a href="https://github.com/PolymerLabs/polylint">polylint</a> was made that does a very basic sanity check of your elements (and follows the dependency chain) giving you some piece of mind in the build process.</p>
<p>Polymer&#39;s <a href="https://github.com/Polymer/polymer-cli">CLI</a> tool includes a linter to make the process easier.</p>
<h2 id="shady-dom">Shady DOM</h2>
<p>webcomponents.js comes in two flavors <em>standard</em> and <em>lite</em>. The <em>lite</em> version contains all the polyfills except the Shadow DOM polyfill. The reason for this is that stubbing Shadow DOM is extremely inefficient and can impact performance of your application significantly!</p>
<p>Specifically, there is a noticeable increase in load time when using the standard version of webcomponentsjs, so unless you explicitly need the Shadow DOM it is recommended you use the <em>lite</em> version.</p>
<p>The <a href="https://www.polymer-project.org/1.0/blog/shadydom">Shady DOM</a> provides the same encapsulation benefits as the Shadow DOM but without the massive polyfill overhead.</p>
<h2 id="polymer-micro">Polymer micro</h2>
<p>If you don&#39;t want all the extra features of Polymer you can instead use <a href="https://www.polymer-project.org/1.0/docs/devguide/experimental#polymer-micro">Polymer micro</a>, which is just a plain wrapper around web components.</p>
<h1 id="summary">Summary</h1>
<h2 id="polymer-pros">Polymer pros</h2>
<p>Polymer is a great tool for building modern web apps, it includes a fast binding system that keeps the UI up to date with no extra effort, and wraps web components to provide all the benefits they are designed to provide.</p>
<h2 id="polymer-cons">Polymer cons</h2>
<p>There is an overhead of loading both Polymer and webcomponents.js and then having to go through the <a href="http://www.w3.org/TR/2013/WD-components-intro-20130606/#element-upgrade">upgrade process</a> of custom elements. This means the user has to wait for the app to load fully before interacting with it (although you can be clever with app framing techniques and asynchronously load parts of the UI to reduce load time).</p>
<p>As time goes on and browsers implement the standard, using Polymer will provide speed enhancements as the Shadow DOM allows for efficient rendering (knowing there is no CSS leaks etc). And with HTTP 2.0 with service workers, a Polymer page will have no speed penalty.</p>
<h2 id="staying-up-to-date-with-polymer">Staying up to date with Polymer</h2>
<p>Polymer is always evolving and getting better. The links below are where all the latest info can be found:</p>
<ul>
<li><a href="https://blog.polymer-project.org">Polymer blog</a></li>
<li><a href="https://github.com/Polymer/project/blob/master/Roadmap.md">Roadmap</a></li>
</ul>
]]></description>
            <link>http://webcomponents.org/articles/a-quick-polymer-introduction</link>
            <guid isPermaLink="true">http://webcomponents.org/articles/a-quick-polymer-introduction</guid>
            <pubDate>Wed, 08 Jun 2016 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[My experience with the Polymer app-route]]></title>
            <description><![CDATA[<p>At the time of writing, the Polymer app-route is in beta. This element is designed to allow Polymer elements data-bind to the url of the site. This blog post will describe some of the issues encountered and depict solutions for said issues.</p>
<!-- Excerpt -->]]></description>
            <link>http://webcomponents.org/articles/my-experience-with-the-polymer-app-route</link>
            <guid isPermaLink="true">http://webcomponents.org/articles/my-experience-with-the-polymer-app-route</guid>
            <pubDate>Sun, 22 May 2016 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Polymer in Production]]></title>
            <description><![CDATA[<p>Lessons learnt from deploying Polymer in a production environment.</p>
<!-- Excerpt -->
<h1 id="bower-bingo">Bower bingo</h1>
<p>At the time of writing, Polymer was dependent on <a href="http://bower.io/">Bower</a> to maintain and install itself and other components. One of the problems is when using large element bases like Google&#39;s <a href="https://elements.polymer-project.org">Paper Elements</a> is that you have a large Bower file to maintain, and on top of that even if you explicitly pin a specific version of a component, it can still itself pull in other dependent elements.</p>
<p>Three solutions are:</p>
<h2 id="manually-pin-all-elements-and-their-dependencies">Manually pin all elements and their dependencies</h2>
<p>Pros: Complete control over all elements<br/>
Cons: Laborious to maintain</p>
<h2 id="commit-bower-components-to-a-repository">Commit Bower components to a repository</h2>
<p>Pros: You can simplify your Bower file, and have confidence in the code going into production<br/>
Cons: Large and messy repository</p>
<h2 id="commit-bower-components-to-a-separate-location">Commit Bower components to a separate location</h2>
<p>Pros: Confidence in code going from testing into production<br/>
Cons: Extra build step required to pull this into codebase</p>
<p>NPM has a useful <a href="https://docs.npmjs.com/cli/shrinkwrap">shrinkwrap</a> ability that would alleviate the problems above.</p>
<p>Polymer NPM support issues:</p>
<ul>
<li><a href="https://github.com/Polymer/polymer/issues/2578#issuecomment-151580862">https://github.com/Polymer/polymer/issues/2578#issuecomment-151580862</a></li>
<li><a href="https://github.com/Polymer/polymer/issues/2525#issuecomment-145355985">https://github.com/Polymer/polymer/issues/2525#issuecomment-145355985</a></li>
</ul>
<h1 id="gulp-build">Gulp build</h1>
<p>Polymer has a vulcanization step that combines all the web components needed into one dependent file (rather than lots of smaller files). This step can be added to gulp:</p>
<pre class="highlight"><code class="hljs javascript"><span class="hljs-keyword">var</span> polybuild = <span class="hljs-built_in">require</span>(<span class="hljs-string">'polybuild'</span>);

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">vulc</span><span class="hljs-params">(name,output)</span></span>{
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>{
    <span class="hljs-keyword">return</span> gulp.src(name)
    .pipe(polybuild({maximumCrush: <span class="hljs-literal">true</span>}))
    .pipe(gulp.dest(output));
  }
}

gulp.task(<span class="hljs-string">'vulcanize_homepage'</span>,vulc(<span class="hljs-string">'src/homepage.html'</span>,<span class="hljs-string">'dist/'</span>));
</code></pre><p><a href="https://github.com/PolymerLabs/polybuild">Polybuild</a> is a tool that lives on top of vulcanize and makes it super easy to vulcanise a file and split the output into two files (one JS and one HTML). The example above combines all the imports for the homepage and saves the output in the <em>dist</em> directory.</p>
<p>When developing your site, vulcanization is not necessary, so you can simplify your pipeline by having two gulp tasks, one for dev that runs and CSS tasks etc and one for production that has the vulcanization step afterwards.</p>
<pre class="highlight"><code class="hljs handlebars"><span class="xml"></span><span class="hljs-expression">{{<span class="hljs-begin-block">#<span class="hljs-keyword">if</span> vulcanized</span>}}</span><span class="xml">
  <span class="hljs-tag">&lt;<span class="hljs-title">link</span> <span class="hljs-attribute">rel</span>=<span class="hljs-value">"import"</span> <span class="hljs-attribute">href</span>=<span class="hljs-value">"/dist/page-home.build.html"</span> /&gt;</span>
</span><span class="hljs-expression">{{<span class="hljs-variable"><span class="hljs-keyword">else</span></span>}}</span><span class="xml">
  <span class="hljs-tag">&lt;<span class="hljs-title">link</span> <span class="hljs-attribute">rel</span>=<span class="hljs-value">"import"</span> <span class="hljs-attribute">href</span>=<span class="hljs-value">"/bower_components/polymer/polymer.html"</span> /&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-title">link</span> <span class="hljs-attribute">rel</span>=<span class="hljs-value">"import"</span> <span class="hljs-attribute">href</span>=<span class="hljs-value">"/src/page-home.html"</span> /&gt;</span>
</span><span class="hljs-expression">{{<span class="hljs-end-block">/<span class="hljs-keyword">if</span></span>}}</span><span class="xml">
</span></code></pre><p>The example above is a templated HTML file that can serve both development purposes, and QA/production purposes depending on whether an environment variable is set.</p>
<h2 id="polylint">Polylint</h2>
<p><a href="https://github.com/PolymerLabs/polylint">Polylint</a> does a very basic sanity check of your elements (and follows the dependency chain) giving you some piece of mind in the build process.</p>
<pre class="highlight"><code class="hljs javascript"><span class="hljs-keyword">var</span> polylint = <span class="hljs-built_in">require</span>(<span class="hljs-string">'polylint'</span>);
<span class="hljs-keyword">var</span> colors = <span class="hljs-built_in">require</span>(<span class="hljs-string">'colors/safe'</span>);

gulp.task(<span class="hljs-string">'polylint'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(cb)</span> </span>{
  <span class="hljs-keyword">var</span> errors = polylint(<span class="hljs-string">'src/elements.html'</span>);

  errors.then(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(errors)</span></span>{
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;i &lt; errors.length;i++) {
      <span class="hljs-keyword">var</span> warning = errors[i];
      warning = colors.red(warning.filename) + <span class="hljs-string">":"</span> +
        warning.location.line + <span class="hljs-string">":"</span> + warning.location.column +
        <span class="hljs-string">"\n    "</span> + colors.gray(warning.message);
      <span class="hljs-built_in">console</span>.log(warning);
    }
    cb();
  });
});
</code></pre><p>The example above starts at the file <em>src/elements.html</em> and lints and follows the dependency tree and prints its output.</p>
<h1 id="docker">Docker</h1>
<p>Once you have a build pipeline (and a way to control external dependencies), one deployment option is Docker. You can deploy your code, and get Docker to build the distribution environment.</p>
<pre class="highlight"><code class="hljs gradle">RUN node_modules<span class="hljs-regexp">/.bin/gu</span>lp polymer_dist
</code></pre><p>The above example calls <code>gulp polymer_dist</code> assuming that everything needed to deploy is contained inside the gulp task.</p>
<p>Docker&#39;s image environment lends itself to a Polymer build system due to the dependencies required. A project can contain many web components made by other people, and a Docker image (when built) will contain a working point in time fixing all dependencies to the version at the point of creation (making rollback easy).</p>
<h2 id="serving-polymer-content">Serving Polymer content</h2>
<p>Once you have built your site, you need a way of serving the content. If your site is purely static you can simply serve the HTML/JS/CSS statically.</p>
<p>If however you want to modify the HTML output you can use any templating solution with a server such as <em>express</em>:</p>
<pre class="highlight"><code class="hljs 1c"><span class="hljs-comment">//Docker</span>
CMD [ <span class="hljs-string">"node"</span>, <span class="hljs-string">"index"</span> ]
</code></pre><pre class="highlight"><code class="hljs actionscript"><span class="hljs-comment">//index.js</span>

<span class="hljs-keyword">var</span> express = require(<span class="hljs-string">'express'</span>);
<span class="hljs-keyword">var</span> app = express();

<span class="hljs-comment">//Setup routes</span>

app.<span class="hljs-keyword">get</span>(<span class="hljs-string">'/profile'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(req, res)</span> </span>{
  <span class="hljs-comment">//Cache for 5 seconds</span>
  res.header(<span class="hljs-string">'Cache-Control'</span>, <span class="hljs-string">'max-age=5'</span>);

  <span class="hljs-comment">//Render page</span>
  res.render(<span class="hljs-string">'profile'</span>,{
      <span class="hljs-comment">//Template parameters</span>
  });
});

<span class="hljs-comment">//Serve static files, + send cache time</span>
app.<span class="hljs-keyword">use</span>(express.<span class="hljs-keyword">static</span>(__dirname + <span class="hljs-string">'/dist/'</span>,{maxAge : <span class="hljs-string">'60s'</span>}));
</code></pre><p>The first code snippet runs <em>node</em> at the end of the Docker build steps.</p>
<p>The second, is the <em>express</em> server with one route (the gets a profile and allows you to modify data if required), and serves other content statically (the compiled JS for example).</p>
<h2 id="global-variables">Global variables</h2>
<p>The advantage of templating is that you can keep the same code for the website and using environment variables switch between a staging environment (QA) and the live environment.</p>
<pre class="highlight"><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-title">script</span>&gt;</span><span class="javascript">
  <span class="hljs-built_in">window</span>.MyGlobals = <span class="hljs-built_in">window</span>.MyGlobals || {};
  <span class="hljs-built_in">window</span>.MyGlobals.APIURL = <span class="hljs-string">'</span></span></span><span class="hljs-expression">{{<span class="hljs-variable">APIADDRESS</span>}}</span><span class="xml"><span class="javascript"><span class="hljs-string">';
</span></span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>
</span></code></pre><p>Using the above code, your Polymer project can reference <code>window.MyGlobals.APIURL</code> when it needs to make a network request and not have any knowledge of the environment it&#39;s in.</p>
<h1 id="caching-and-versioning">Caching and versioning</h1>
<p>As Polymer files are static in nature, once they are built they can be cached indefinitely. Versioning your HTML / JS output from a Polybuild and serving from a CDN will reduce costs and increase performance of your application.</p>
<p>The files that have templated information can also be cached by using the appropriate headers from your server (<em>express</em> example above).</p>
<p>Fixed template variables (such as API endpoints) can be merged into the build step and cached indefinitely in the output.</p>
<h1 id="preloading-images-and-data">Preloading images and data</h1>
<p>Polymer projects can build single page web apps, and all data can be loaded asynchronously using AJAX. The problem is that none of these calls will be made until Polymer has finished loading and upgrading the elements.</p>
<p>If you have any data which you know in advance, you can build it into your pipeline so that when Polymer requests the data the browser already has it in its cache.</p>
<p>For example if you have some dynamic images loading above-the-fold (and you can compute what they will be ahead of time) you can inject JavaScript into your page to fetch these as soon as the page starts to load so they are warm in the cache when Polymer requests them (when using <a href="https://github.com/PolymerElements/iron-image">iron-image</a> for example).</p>
<p>As browser performance increases (and HTTP 2.0 is introduced) these optimisations will not be necessary.</p>
<h1 id="google-analytics">Google Analytics</h1>
<p>Using Google Analytics, you can view your rendering times across your user base which gives a good indicator of your Polymer performance (from server response time to browser render time). You can create custom dashboards to monitor the stats you need the most (browser usage, popular pages render time etc).</p>
<h1 id="full-polymer-website-examples">Full Polymer website examples</h1>
<ul>
<li><a href="http://gaming.youtube.com">YouTube Gaming</a></li>
<li><a href="https://elements.polymer-project.org">Polymer Catalog</a></li>
<li><a href="https://wakelet.com">Wakelet</a></li>
</ul>
]]></description>
            <link>http://webcomponents.org/articles/polymer-in-production</link>
            <guid isPermaLink="true">http://webcomponents.org/articles/polymer-in-production</guid>
            <pubDate>Tue, 26 Jan 2016 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Web Components in production use – are we there yet?]]></title>
            <description><![CDATA[<p>A lot of progress has been made since the introduction of the Web Components back in 2011. All major browsers have started implementation of the technologies needed to run web components natively. While browser vendors are still working on native implementations, libraries have been able to use a polyfill to make web components available to developers already.</p>
<p>But what is the status of Web Components for actual production use in business applications?</p>
<!-- Excerpt -->]]></description>
            <link>http://webcomponents.org/articles/web-components-in-production-use-are-we-there-yet</link>
            <guid isPermaLink="true">http://webcomponents.org/articles/web-components-in-production-use-are-we-there-yet</guid>
            <pubDate>Tue, 26 Jan 2016 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Polymer Testing Tips]]></title>
            <description><![CDATA[<p>This article goes through some of the more advanced topics such as user interaction simulation, automatic testing with Continuous Integration, testing on multiple OS/browsers, and more useful tips.</p>
<!-- Excerpt -->]]></description>
            <link>http://webcomponents.org/articles/polymer-testing-tips</link>
            <guid isPermaLink="true">http://webcomponents.org/articles/polymer-testing-tips</guid>
            <pubDate>Tue, 05 Jan 2016 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Sane usage of Custom Elements]]></title>
            <description><![CDATA[<p>Web Components have been an controversial subject that surfaced the Front end world over the last years that I&#39;m still pretty skeptical about its usage on existing and greenfield projects due the lack of good examples on how they can be rolled out to production, but there is sure a way to get started with them without buying in all the hype.</p>
<!-- Excerpt -->]]></description>
            <link>http://webcomponents.org/articles/sane-usage-of-custom-elements</link>
            <guid isPermaLink="true">http://webcomponents.org/articles/sane-usage-of-custom-elements</guid>
            <pubDate>Fri, 25 Sep 2015 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[There is an Element for That]]></title>
            <description><![CDATA[<p>Sebastian attended to the first ever Polymer Summit in Amsterdam recently. This was his first Polymer conference obviously but this was also his first conference &amp; trip to Amsterdam. As an AngularJS developer he was very curious about the Polymer Project and the ambitious ideas behind it. Here is what he had to say.
<!-- Excerpt --></p>
]]></description>
            <link>http://webcomponents.org/articles/there-is-an-element-for-that</link>
            <guid isPermaLink="true">http://webcomponents.org/articles/there-is-an-element-for-that</guid>
            <pubDate>Sat, 19 Sep 2015 00:00:00 GMT</pubDate>
        </item>
    </channel>
</rss>